#+TITLE:     
#+AUTHOR:    Massimo Lauria
#+EMAIL:     lauria@kth.se
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:nil toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+EXPORT_EXCLUDE_TAGS: noexport
#+HTML_HEAD_EXTRA: <meta charset='utf-8'>
#+HTML_HEAD_EXTRA: <meta http-equiv="X-UA-Compatible" content="chrome=1">
#+HTML_HEAD_EXTRA: <meta name="description" content="CNFgen : Cool benchmarks for your SAT solver!">
#+HTML_HEAD: <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
#+HTML_HEAD: <style type="text/css"> .title  { height: 0; margin: 0;} </style>


#+begin_html
<!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/MassimoLauria/cnfgen">View on GitHub</a>

          <h1 id="project_title"><a id="project_title" href="https://massimolauria.github.io/cnfgen">CNFgen</a></h1>
          <h2 id="project_tagline">Cool benchmarks for your SAT solver!</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/MassimoLauria/cnfgen/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/MassimoLauria/cnfgen/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>
#+end_html
#+begin_html
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
#+end_html

CNFgen is a tool that  produces the combinatorial benchmarks in DIMACS
format for  SAT solvers, coming  mostly from classic  and cutting-edge
research  in Proof  Complexity  (e.g.  pigeonhole principle,  ordering
principle,  k-clique, …).  Many  of these  formulas encode  structured
combinatorial  problems,  some of  then  well  known  to be  hard  for
SAT solver.

* Features

  - =cnfgen= generator for [[file:background.org][CNF formula]] benchmarks,
  - the python library =cnfformula= for more flexible CNF generation and manipulation,
  - behind-the-scene integration with many SAT solvers,
  - output in DIMACS and LaTeX formats,
  - formula [[file:transformation.org][post-processing]].

* Installation
  
  You can install CNFgen from  [[http://pypi.python.org][Python Package Index]], together with all
  its dependencies, typing either

  : easy_install [--user] cnfgen

  or

  : pip install  [--user] cnfgen

  Otherwise it  is possible to install from source using
   
  : python setup.py install [--user]

  In all  cases the =--user= option  allows to install the  package in
  the user home directory. In this case please check that the location
  where the command line utilities are installed is in your =PATH=.
   
* Quickstart 

  If you are eager to generate benchmarks, here is a list of examples
  for each  formula class. See [[commandline][below]] for a gentler explanation  of to
  how invoke  =cnfgen=, or run  =cnfgen --help=. To get  more specific
  information on one formula type use

  : cnfgen <formula_type> --help

*** Pigeonhole Principle

    Pigeonhole principle from $m$ pigeons to $n$ holes,

    : cnfgen php <m> <n>

    You can  add functional  and onto clauses  using the  command line
    options.

    : cnfgen php [--functional] [--onto] <m> <n>

# *** Graph Pigeonhole Principle
#
#     Essentially  the   same  as   pigeonhole  principle  but   it  has
#     a bipartite graph as input.
#     
#     : cnfgen gphp <m> <n>

*** Tseitin  formulas

    The  Tseitin formula  on  a graph  $G$ (given  in  input) has  the
    command line

    : cnfgen tseitin –charge <type> -i <input_graph>

    The initial  charge of vertices is  either =first=  (only the
    first  vertex is  labeled 1) or  one  of =random=,  =randomodd=,
    =randomeven=.

    For example this produces a =tseitin= formula over a 10 by 10 grid
    graph, with random labeling of the vertices.
    
    : cnfgen tseitin --charge random --grid 10 10

    
*** Ordering principle

    The ordering principle over N elements is generated by

    : cnfgen op <N>

    It is possible to consider total orders with 

    : cnfgen -t op <N>

*** Graph ordering principle

    
    The graph ordering principle over an input graph 

    : cnfgen gop -i <input_graph>
    
    The  vanilla ordering  principle equivalent  to the  graph ordering
    principle if  the underlying graph is  the complete one, as  in the
    example

    : cnfgen gop --complete 30
    
*** Pebbling formula

    For  example we  can generate  the  pebbling formula  for a  rooted
    binary tree of height 10 with
    
    : cnfgen peb --tree 10

    and we can do the same for a graph in input using 

    : cnfgen peb -i <input_dag>

*** K-clique formula

    If given a graph G, the formula  claims that there is no clique of
    size at least k in the graph G. 

    : cnfgen kclique <k> -i <input_graph> 

    The formula generated by

    : cnfgen kclique 10 --gnp 200 0.5 --plantclique 15
    
    claims that  there is a clique  of size 10 in  a random Erdös-Renyi
    graph with 200 vertices where a clique of size 15 has been planted.

*** Ramsey number formula
   
    The command line

    : cnfgen ram <s> <k> <N>

    produces a  formula that claims  that the Ramsey number  r(s,k) is
    larger than N.



* The CNFgen command line<<commandline>>

  The command line to produce a DIMACS file is

  : cnfgen [-o <output_file>] <formula_type> <formula_parameters>

  where each  choice of  =<formula_type>= has  its own  parameters and
  options.  For  example here's  how  to  get a  pigeonhole  principle
  formula from 10 pigeons to 7 holes printed to standard output:

  : cnfgen php 10 7 

  We implement  several families of  formula in =cnfgen= tool.  Now we
  briefly  describe  some  of  them, with  the  principal  parameters.
  For  a  full  list  of implemented  formula  families  type  =cnfgen
  --help=. To get specific information on one family use

  : cnfgen <formula_type> --help

  Some formulas require a graph  (simple, DAG, bipartite) given either
  in some of the formats supported by the graph library [[https://networkx.github.io/][NetworkX]], or
  in the [[file:kthformat.org][KTH graph format]]. More importantly =cnfgen=  can generate the
  graph itself. Here's how to generate the graph ordering principle on
  a random graph of 10 vertices and degree 3.

  : cnfgen gop --gnd 10 3

  Or a 3-colorability formula on a 15 by 15 grid graph. 

  : cnfgen kcolor 3 --grid 15 15


* Acknowledgments

  The CNFgen project is  by Massimo Lauria ([[mailto:lauria.massimo@gmail.com][lauria.massimo@gmail.com]]),
  with helps and contributions by Marc Vinyals, Mladen Mikša and [[http://www.csc.kth.se/~jakobn/][Jakob
  Nordström]]  from  KTH Royal  Institute  of  Technology in  Stockholm,
  Sweden. Massimo Lauria is maintaining  and developing the tool while
  funded by the  European Research Council under  the European Union's
  Seventh  Framework Programme  (FP7/2007--2013)  ERC grant  agreement
  no. 279611.


#+begin_html
    </section></div>
#+end_html
#+begin_html
    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">CNFgen maintained by <a href="https://github.com/MassimoLauria">MassimoLauria</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>
#+end_html

# Local variables:
# org-html-preamble: nil
# org-html-postamble: nil
# org-html-toplevel-hlevel: 3
# org-html-head-include-default-style: nil
# End:
