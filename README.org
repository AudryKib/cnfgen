#+LANGUAGE:    en
#+OPTIONS:     H:2 num:nil toc:nil \n:nil @:t ::t |:t ^:t f:t TeX:t


* CNF formula generator and tools

  This repository provides the python programs

  =cnfgen.py=
  =reshuffle.py=
  =dimacstransform.py=
  =kth2dimacs.py=

  You  can get  a brief  help on  how to  use these  tools by  running
  =<program_name> --help= from the command line.
 
  Tool =cnfgen= is CNF formulas generator (i.e. propositional formulas
  in conjunctive normal form). It produce formulas of interest for the
  proof  complexity  community  (e.g. pigeonhole  principle,  ordering
  principle, …)  both in  dimacs and LaTeX  format. The  basic command
  line to get the dimacs version of a formula is 

  : cnfgen.py -o <output_file> <formula_type> <formula_parameters>

  Each  formula family  has its  own parameters  and options.  Some of
  them even  require further input.  To get more  specific information
  on each formula family type

  : cnfgen.py <formula_type> --help

  =cnfgen= allows  to apply  transformations on the  generated formula
  afterward.   These transformations  systematically make  the formula
  harder for SAT solver, so they are of interest for proof complexity. 
  
  : cnfgen.py -o <ofile> --Transform <type> --Tarity <N> <ftype> <fparameters>

  To get more information about the available transformation types
  
  : cnfgen.py --help-transformation

  Here's how to get a pigeonhole  principle formula from 10 pigeons to
  7 holes into file =pigeon.cnf=:

  : cnfgen.py -o pigeon.cnf php 10 7 


  =reshuffle=  takes a  CNF in  input and  outputs the  same CNF  with
  a  random  variables  order,  clauses order  and  variable  polarity
  flips.

  : reshuffle.py -i <input_cnf> -o <output_cnf> [-S random_seed]

  =dimacstransform= applies  formula transformations to any  CNF given
  in input. The command line

  : dimacstransform.py --Transform <type> --Tarity <N> -i <input_cnf> -o <output_cnf>
  
  applies transformation =<type>= of arity N to the input CNF. To see the
  available types of transformation.

  : dimacstransform.py --help-transformation

  =kth2dimacs= gets  a directed  acyclic graph in  input in  KTH graph
  format  (see  below),  and   produces  the  corresponding  *pebbling
  formula*. Optionally can apply formula transformation afterward.

  : kyh2dimacs.py [--Transform <type> --Tarity <N>] -i <input_graph>
 
*** KTH graph format
   
    Graphs must be  given in the following format: the  file can start
    with some comments line, each of them starting with character =c=.
    The next non  black line must contain the number  n of vertices in
    the graph.  Then  there must be $n$ non black  lines, one for each
    vertex 1 ≤ i ≤ n. The lines have the format:

    : i : <pred 1> <pred 2> <pred 3> ... <pred k>
    
    where =<pred  1> <pred 2>  <pred 3> ...  <pred k>= is  the ordered
    list  of  all vertices  which  have  an  outgoing edge  to  vertex
    i. Here’s an example

    : c
    : c This is a DAG of 5 vertices
    : c
    : 5
    : 1  :
    : 2  : 
    : 3  : 1  
    : 4  : 3  
    : 5  : 2  4
   


  *Performance*: the code contains a lot of sanity checks and internal
  safe nets.   They take  a toll  on the running  time and  memory: to
  avoid that you can use the  python optimization flag =-O= which will
  (among other thing) suppress these checks.

  : python -O <program_name> [command line options for <program_name>]


** Target of the software

   Anyone can use this software of  course! But the main target is the
   community  of SAT  solver programmers,  who may  want to  test they
   solvers  on  canonical  families  of  formulas.   Proof  complexity
   researcher may be interested to, since they study the computational

** Requirements

   =cnfgen= requires  either Python  2.7 *or* the  =argparse= library,
   which is included in the standard Python library since version 2.7.

   Optionals requirements are

   - =networkx= library, which is used to parse some input formats for
     specifying graphs.

   - =pygraphviz= which  is also used to read  some graph formats.

   If any  optional requirement is missing, the  relative features are
   not activated.

* Formula Families

* Formula Transformations

* Background

** What is a CNF?

   A propositional formula a  representation of a function oven {0,1}
   variables. Consider such a variable  x, then ¬x is a formula
   which  has  value 1-x.  This  is  called  the /negation/  of  x.
   Expressions of the form x  and ¬x are called \literals/, and
   a /clause/ is a disjunction

   l₁ v l₂ v … v lₖ

   where each lᵢ is a literal. A clause evaluates to one if and only
   if *at  least* one of the  literals evaluates to  one. Otherwise the
   clause evaluates to zero.
   A CNF is a conjunction of clauses

   C₁ ∧ C₂ ∧ … ∧ Cₘ

   and the CNF evaluates to one if *all* clauses evaluates to one.

   To  *falsify* a  formula we  need an  input for  which the  formula
   evaluates to 0;  to *satisfy* a formula we need  an input for which
   it evaluates to 1.  Observe that  to falsify a CNF it is sufficient
   to pick  a clause  and set  the variables  in such  a way  that all
   literals in  the clause  evaluate to zero.   There is  no efficient
   algorithm that decides whether a CNF is satisfiable or not.

** DIMACS encoding of CNFs

   The program outputs CNF formulas  encoded in /dimacs/ format, which
   has the following structure:

   at the  beginning of the file  there may be an  arbitrary number of
   comment lines, which  must start with character =c=.  The first non
   comment line specifies how many  variables and how many clauses are
   in  the CNF  formulas.  The next  lines are  sequence  of non  zero
   integers followed by zero.
   : p cnf <N> <M>
   : <i> <i> <i> <i> 0
   : <i> <i> <i> 0
   : ...
   Each  line  after the  specification  represents  a clause  in  the
   following way:  a positive number t  is the positive literal on the
   variable indexed by t.  A negative  number t is the negated literal
   on  the variable  indexed by  -t.  

   For example if the formula is defined  on n variables x₁, x₂, …, xₙ
   then the line =3 -1 5 6 -4 0= encodes the clause x3 v ¬x₁ v x₅ v x₆ v ¬x₄.


