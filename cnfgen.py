#!/usr/bin/env python

"""
AUTHOR: Massimo Lauria <lauria@kth.se>
COPYRIGHT: Massimo Lauria, 2012

The module contains facilities to generate cnf formulas in dimacs
format. Such formulas are ready to be fed to sat solvers.

"""

from __future__ import print_function
import itertools


class CNF(object):
    """Formula in conjunctive normal form
    """

    def __init__(self, clauses=[]):
        """Build the CNF with an optional set of initial clauses

        To add commented clauses use the `add_clause` and
        `add_comment` methods.

        Arguments:
        - `clauses`: ordered list of clauses; a clause with k literals
                     is a tuple with 2k position. Odd ones are the
                     polarities, even one are utf8 encoded string with
                     variable names.

                     E.g. (not x3) or x4 or (not x2) is encoded as (False,u"x3",True,u"x4",False,u"x2")
        """
        self._clauses = []
        self._name_to_id = {}
        self._id_to_name = {}

        for c in clauses:
            if type(c)==str:
                self.add_comment(c)
            else:
                self.add_clause(c)


    def add_clause(self,clause):
        """Add a well formatted clause to the CNF. It raises
           `ValueError` if the clause is not well formatted.

        Arguments:
        - `self`:
        - `clause`: a clause with k literals is a list with k pairs.
                    First coords are the polarities, second coords are
                    utf8 encoded strings with variable names.

                    E.g. (not x3) or x4 or (not x2) is encoded as
                         [(False,u"x3"),(True,u"x4"),(False,u"x2")]
        """
        new_clause=[]
        # Check for the format
        for neg,var in clause:
            if type(neg)!=bool or type(var) != str:
                raise TypeError("%s is not a well formatted clause" %clause)
            new_clause.append((neg,var))
        # Add all missing variables
        for _,var in new_clause:
            if not var in self._name_to_id:
                id=len(self._name_to_id)+1
                self._name_to_id[var]=id
                self._id_to_name[id]=var
        # Add the clause
        self._clauses.append(new_clause)

    def add_variable(self,var):
        """Add a variable to the formula. This is useful to add
        the variable in a nice order than the appearence one.

        Arguments:
        - `self`:
        - `var`: the name of the variable to add (string).
        """
        if type(var) != str:
            raise TypeError("The name of a variable must be a string" %clause)

        if not var in self._name_to_id:
            id=len(self._name_to_id)+1
            self._name_to_id[var]=id
            self._id_to_name[id]=var

    def add_comment(self,comment):
        """Add a comment to the formula. Useful for documenting DIMACS format cnfs.

        Arguments:
        - `comment`: an unicode string of text.
        """
        self._clauses.append(comment[:])

    def dimacs(self,outputfile=None):
        """
        Produce the dimacs encoding of the formula
        """

        # Count the number of variables and clauses
        n = len(self._name_to_id)
        m = len([c for c in self._clauses if type(c)!=str])

        # A nice header
        print(u"c Formula generated by cnfgen.")
        print(u"c \"cnfgen\" has been written by Massimo Lauria. Copyright, 2012")
        print(u"c")
        print(u"p cnf {0} {1}".format(n,m))

        # We produce clauses and comments
        for c in self._clauses:
            if type(c)==str:
                print(u"c "+c)               # output the comment
            else:
                for neg,var in c:
                    v = self._name_to_id[var]
                    if not neg: v = -v
                    print(u"{0} ".format(v),end="")
                print(u"0")


def PHP(pigeons,holes,functional=False,onto=False):
    """Generates the clauses of pigeonhole principle CNF encoding

    Arguments:
    - `pigeon`: number of pigeons
    - `hole`:   number of holes
    - `functional`: add clauses to enforce at most one hole per pigeon
    - `onto`: add clauses to enforce that any hole must have a pigeon
    """
    if functional:
        if onto:
            formula_name="Matching"
        else:
            formula_name="Functional pigeonhole principle"
    else:
        if onto:
            formula_name="Onto pigeonhole principle"
        else:
            formula_name="Pigeonhole principle"

    yield "{0} formula for {1} pigeons and {2} holes".format(formula_name,pigeons,holes)

    # Pigeon axioms
    for p in xrange(1,pigeons+1):
        yield "Pigeon axiom: pigeon {0} sits in a hole".format(p)
        yield [ (True,'p_{{{0},{1}}}'.format(p,h)) for h in xrange(1,holes+1)]

    # Onto axioms
    if onto:
        for h in xrange(1,holes+1):
            yield "Onto hole axiom: hole {0} hosts a pigeon".format(h)
            yield [ (True,'p_{{{0},{1}}}'.format(p,h)) for p in xrange(1,pigeons+1)]

    # No conflicts axioms
    for h in xrange(1,holes+1):
        yield "No collision in hole {0}".format(h)
        for (p1,p2) in itertools.combinations(range(1,pigeons+1),2):
            yield [ (False,'p_{{{0},{1}}}'.format(p1,h)),
                    (False,'p_{{{0},{1}}}'.format(p2,h)) ]

    # Function axioms
    if functional:
        for p in xrange(1,pigeons+1):
            yield "No multiple images for pigeon {0}".format(p)
            for (h1,h2) in itertools.combinations(range(1,holes+1),2):
                yield [ (False,'p_{{{0},{1}}}'.format(p,h1)),
                        (False,'p_{{{0},{1}}}'.format(p,h2)) ]

def GT(size,total=False):
    """Generates the clauses of ordering principle

    Arguments:
    - `size`:   numer of elements
    - `total`:  add clauses to enforce totality
    """
    # Describe the formula
    if total:
        yield "Total ordering principle for the graph:"
    else:
        yield "Ordering principle for the graph:"
    yield ""
    yield ""

    # Non minimality axioms
    yield "Each vertex has a predecessor"
    for v in xrange(size):
        clause = []
        for u in xrange(v):
            clause += [(True,'x_{{{0},{1}}}'.format(u,v))]
        for w in xrange(v+1,size):
            if total:
                clause += [(False,'x_{{{0},{1}}}'.format(v,w))]
            else:
                clause += [(True,'x_{{{0},{1}}}'.format(w,v))]
        yield clause

    # Transitivity axiom
    yield "Relation must be transitive"

    if size>=3:
        if total:
            # Optimized version if totality is included (less formulas)
            for (v1,v2,v3) in itertools.combinations(xrange(size),3):
                yield [ (True,'x_{{{0},{1}}}'.format(v1,v2)),
                        (True,'x_{{{0},{1}}}'.format(v2,v3)),
                        (False,'x_{{{0},{1}}}'.format(v1,v3))]
                yield [ (False,'x_{{{0},{1}}}'.format(v1,v2)),
                        (False,'x_{{{0},{1}}}'.format(v2,v3)),
                        (True,'x_{{{0},{1}}}'.format(v1,v3))]
        else:
            for (v1,v2,v3) in itertools.permutations(xrange(size),3):
                yield [ (False,'x_{{{0},{1}}}'.format(v1,v2)),
                        (False,'x_{{{0},{1}}}'.format(v2,v3)),
                        (True, 'x_{{{0},{1}}}'.format(v1,v3))]

    # Antisymmetry axioms
    if not total:
        yield "Relation must be anti-symmetric"
        for (v1,v2) in itertools.permutations(xrange(size),2):
            yield [ (False,'x_{{{0},{1}}}'.format(v1,v2)),
                    (False,'x_{{{0},{1}}}'.format(v2,v1))]

def RAM(s,k,N):
    """Formula claiming that Ramsey number r(s,k) > N

    Arguments:
    - `s`: independent set size
    - `k`: clique size
    - `N`: vertices
    """

    yield "CNF encoding of the claim that:"
    yield "there is a graph of N vertices with no"
    yield " clique of size k and not indipendent set of size s."

    # No independent set of size s
    for vertex_set in itertools.combinations(xrange(1,N+1),s):
        clause=[]
        for edge in itertools.combinations(vertex_set,2):
            clause+=[(True,'e_{{{0},{1}}}'.format(*edge))]
        yield clause

    # No clique of size k
    for vertex_set in itertools.combinations(xrange(1,N+1),k):
        clause=[]
        for edge in itertools.combinations(vertex_set,2):
            clause+=[(False,'e_{{{0},{1}}}'.format(*edge))]
        yield clause



class _Graph(object):
    """Simple graph class for internal representation.
    """

    def __init__(self, V,E):
        """
        Build the graph for a set of vertices and edges. If the
        list of edges names some vertex which is not in the list V, it
        is appended to the list. In particular the list is given for
        adding isolated vertices or to enforce some order.

        Arguments:
        - `V`: initial list of vertices
        - `E`: edges of the graph.
        """
        self._V = V
        self._E = []
        # Sanitize edge list
        for (u,v) in E:
            if (u,v) in self._E: pass
            if (v,u) in self._E: pass
            if not u in V: V.append(u)
            if not v in V: V.append(v)

    def _get_edges(self):
        return self._E

    edges = property(_get_edges)

    def _get_vertices(self):
        return self._vertices

    vertices = property(_get_vertices)




if __name__ == '__main__':
    # Parse the command line arguments

    # Select the appropriate generator

    # Output the formula
    c=CNF(RAM(4,3,8))
    c.dimacs()
