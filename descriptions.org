#+TITLE:     
#+AUTHOR:    Massimo Lauria
#+EMAIL:     lauria@kth.se
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:nil toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+EXPORT_EXCLUDE_TAGS: noexport
#+HTML_HEAD_EXTRA: <meta charset='utf-8'>
#+HTML_HEAD_EXTRA: <meta http-equiv="X-UA-Compatible" content="chrome=1">
#+HTML_HEAD_EXTRA: <meta name="description" content="CNFgen : Cool benchmarks for your SAT solver!">
#+HTML_HEAD: <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
#+HTML_HEAD: <style type="text/css"> .title  { height: 0; margin: 0;} </style>


#+begin_html
<!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/MassimoLauria/cnfgen">View on GitHub</a>

          <h1 id="project_title"><a id="project_title" href="https://massimolauria.github.io/cnfgen">CNFgen</a></h1>
          <h2 id="project_tagline">Cool benchmarks for your SAT solver!</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/MassimoLauria/cnfgen/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/MassimoLauria/cnfgen/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>
#+end_html
#+begin_html
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
#+end_html

The =cnfgen= tool implements several  families of formulas. We briefly
describe  them, and  their principal  parameters. For  a full  list of
implemented  formula families  type =cnfgen  --help=. To  get specific
information on one each family use

: cnfgen <formula_type> --help


** Pigeonhole Principle

   The formula  claims that  it is  possible to assign $m$ pigeons  to $n$
   holes so that

   - each pigeon gets at least a hole;
   - no to pigeons get the same hole.

   : cnfgen php <m> <n>

   This formula is clearly unsatisfiable in $m>n$. In literature there
   are other variants of this formula:

   - in *functional* PHP every pigeon is assigned to exactly one hole;
   - in *onto* PHP every hole must contain at least a pigeon;
   - *matching* PHP has both *functional* and *onto* clauses.

   You can  add functional  and onto clauses  using the  command line
   options.

   : cnfgen php [--functional] [--onto] <m> <n>

** Tseitin  formulas

   Tseitin  formula  represent a  particular  linear  system based  on
   graphs. Start  from a  graph G  such that  each vertex  is labelled
   either 0 or 1. The formula claim that  you can put labels 0 or 1 on
   the edges of G  so that the label of each vertex v  is equal to the
   sum of the labels on the edges incident to v (module 2).

   : cnfgen tseitin –charge <type> -i <input_graph>

   The initial  charge of  the vertices is  either =first=  (only the
   first  vertex is  labeled 1) or  one  of =random=,  =randomodd=,
   =randomeven=.

   While in general the graph can be provided in input, there are some
   immediately usable.
   
   : cnfgen tseitin --charge random --grid 10 10

   Produces  a =tseitin=  formula over  a 10  by 10  grid graph,  with
   labeling of the vertices uniformily random.

** Ordering principle

   The  formula claims  that  there is  partial order  over  a set  of
   N elements, such  that every element has at  least one predecessor.
   For example the  DIMACS formula for the ordering  principle over 30
   elements is generated by

   : cnfgen op 30
   
   The graph ordering  principle is a variant  of ordering principle:
   given a graph G  of n vertices, the formula claim  that there is a
   partial (or total) order on V(G),  such that every vertex there is
   another one which is
   
   - a predecessor in the order;
   - a neighbor in the graph.

   : cnfgen gop -i <input_graph>
   
   The  vanilla ordering  principle equivalent  to the  graph ordering
   principle if  the underlying graph is  the complete one, as  in the
   example

   : cnfgen gop --complete 30
   
** Pebbling formula

   A directed acyclic graph G has some vertices with no incoming arcs
   (*sources*) and  vertices with no  outgoing arcs (*sinks*).  For a
   given directed acyclic graph G,  the pebbling formula for G claims
   that:
   
   - there is a pebble on every source;
   - if all predecessors  of vertex v are pebbled, then  v is pebbled
     too;
   - the sinks are not pebbled.

   For  example we  can generate  the  pebbling formula  for a  rooted
   binary tree of height 10 with
   
   : cnfgen peb --tree 10

   and we can do the same for a graph in input using 

   : cnfgen peb -i <input_dag>

** K-clique formula

   If given a graph G, the formula  claims that there is no clique of
   size at least k in the graph G. 

   : cnfgen kclique <k> -i <input_graph> 

   There is the additional option  =--plantclique= that plant a random
   clique  in the  graph. In  this  way it  is possible  to study  the
   behavior of SAT solver on  the /hidden clique problem/. For example
   the formula generated by

   : cnfgen kclique 10 --gnp 200 0.5 --plantclique 15
   
   claims that  there is a clique  of size 10 in  a random Erdös-Renyi
   graph with 200 vertices where a clique of size 15 has been planted.

** Ramsey number formula
  
   The simplest  version of the  famous /Ramsey theorem/ says  that for
   every s and  k there is a  number r(s,k) such that  every graph of
   r(s,k)  vertices has  either an  independent set  of size  s or  a
   clique of size k. Command line

   : cnfgen ram <s> <k> <N>

   produces  a formula  that claims  that r(s,k)>N.


